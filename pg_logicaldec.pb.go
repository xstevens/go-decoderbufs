// Code generated by protoc-gen-go.
// source: pg_logicaldec.proto
// DO NOT EDIT!

/*
Package decoderbufs is a generated protocol buffer package.

It is generated from these files:
	pg_logicaldec.proto

It has these top-level messages:
	Point
	DatumMessage
	RowMessage
*/
package decoderbufs

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Op int32

const (
	Op_INSERT Op = 0
	Op_UPDATE Op = 1
	Op_DELETE Op = 2
)

var Op_name = map[int32]string{
	0: "INSERT",
	1: "UPDATE",
	2: "DELETE",
}
var Op_value = map[string]int32{
	"INSERT": 0,
	"UPDATE": 1,
	"DELETE": 2,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}

type Point struct {
	X float64 `protobuf:"fixed64,1,opt,name=x" json:"x,omitempty"`
	Y float64 `protobuf:"fixed64,2,opt,name=y" json:"y,omitempty"`
}

func (m *Point) Reset()         { *m = Point{} }
func (m *Point) String() string { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()    {}

type DatumMessage struct {
	ColumnName string `protobuf:"bytes,1,opt,name=column_name" json:"column_name,omitempty"`
	ColumnType int64  `protobuf:"varint,2,opt,name=column_type" json:"column_type,omitempty"`
	// Types that are valid to be assigned to Datum:
	//	*DatumMessage_DatumInt32
	//	*DatumMessage_DatumInt64
	//	*DatumMessage_DatumFloat
	//	*DatumMessage_DatumDouble
	//	*DatumMessage_DatumBool
	//	*DatumMessage_DatumString
	//	*DatumMessage_DatumBytes
	//	*DatumMessage_DatumPoint
	Datum isDatumMessage_Datum `protobuf_oneof:"datum"`
}

func (m *DatumMessage) Reset()         { *m = DatumMessage{} }
func (m *DatumMessage) String() string { return proto.CompactTextString(m) }
func (*DatumMessage) ProtoMessage()    {}

type isDatumMessage_Datum interface {
	isDatumMessage_Datum()
}

type DatumMessage_DatumInt32 struct {
	DatumInt32 int32 `protobuf:"varint,3,opt,name=datum_int32,oneof"`
}
type DatumMessage_DatumInt64 struct {
	DatumInt64 int64 `protobuf:"varint,4,opt,name=datum_int64,oneof"`
}
type DatumMessage_DatumFloat struct {
	DatumFloat float32 `protobuf:"fixed32,5,opt,name=datum_float,oneof"`
}
type DatumMessage_DatumDouble struct {
	DatumDouble float64 `protobuf:"fixed64,6,opt,name=datum_double,oneof"`
}
type DatumMessage_DatumBool struct {
	DatumBool bool `protobuf:"varint,7,opt,name=datum_bool,oneof"`
}
type DatumMessage_DatumString struct {
	DatumString string `protobuf:"bytes,8,opt,name=datum_string,oneof"`
}
type DatumMessage_DatumBytes struct {
	DatumBytes []byte `protobuf:"bytes,9,opt,name=datum_bytes,proto3,oneof"`
}
type DatumMessage_DatumPoint struct {
	DatumPoint *Point `protobuf:"bytes,10,opt,name=datum_point,oneof"`
}

func (*DatumMessage_DatumInt32) isDatumMessage_Datum()  {}
func (*DatumMessage_DatumInt64) isDatumMessage_Datum()  {}
func (*DatumMessage_DatumFloat) isDatumMessage_Datum()  {}
func (*DatumMessage_DatumDouble) isDatumMessage_Datum() {}
func (*DatumMessage_DatumBool) isDatumMessage_Datum()   {}
func (*DatumMessage_DatumString) isDatumMessage_Datum() {}
func (*DatumMessage_DatumBytes) isDatumMessage_Datum()  {}
func (*DatumMessage_DatumPoint) isDatumMessage_Datum()  {}

func (m *DatumMessage) GetDatum() isDatumMessage_Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *DatumMessage) GetDatumInt32() int32 {
	if x, ok := m.GetDatum().(*DatumMessage_DatumInt32); ok {
		return x.DatumInt32
	}
	return 0
}

func (m *DatumMessage) GetDatumInt64() int64 {
	if x, ok := m.GetDatum().(*DatumMessage_DatumInt64); ok {
		return x.DatumInt64
	}
	return 0
}

func (m *DatumMessage) GetDatumFloat() float32 {
	if x, ok := m.GetDatum().(*DatumMessage_DatumFloat); ok {
		return x.DatumFloat
	}
	return 0
}

func (m *DatumMessage) GetDatumDouble() float64 {
	if x, ok := m.GetDatum().(*DatumMessage_DatumDouble); ok {
		return x.DatumDouble
	}
	return 0
}

func (m *DatumMessage) GetDatumBool() bool {
	if x, ok := m.GetDatum().(*DatumMessage_DatumBool); ok {
		return x.DatumBool
	}
	return false
}

func (m *DatumMessage) GetDatumString() string {
	if x, ok := m.GetDatum().(*DatumMessage_DatumString); ok {
		return x.DatumString
	}
	return ""
}

func (m *DatumMessage) GetDatumBytes() []byte {
	if x, ok := m.GetDatum().(*DatumMessage_DatumBytes); ok {
		return x.DatumBytes
	}
	return nil
}

func (m *DatumMessage) GetDatumPoint() *Point {
	if x, ok := m.GetDatum().(*DatumMessage_DatumPoint); ok {
		return x.DatumPoint
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DatumMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _DatumMessage_OneofMarshaler, _DatumMessage_OneofUnmarshaler, []interface{}{
		(*DatumMessage_DatumInt32)(nil),
		(*DatumMessage_DatumInt64)(nil),
		(*DatumMessage_DatumFloat)(nil),
		(*DatumMessage_DatumDouble)(nil),
		(*DatumMessage_DatumBool)(nil),
		(*DatumMessage_DatumString)(nil),
		(*DatumMessage_DatumBytes)(nil),
		(*DatumMessage_DatumPoint)(nil),
	}
}

func _DatumMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DatumMessage)
	// datum
	switch x := m.Datum.(type) {
	case *DatumMessage_DatumInt32:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.DatumInt32))
	case *DatumMessage_DatumInt64:
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.DatumInt64))
	case *DatumMessage_DatumFloat:
		b.EncodeVarint(5<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(math.Float32bits(x.DatumFloat)))
	case *DatumMessage_DatumDouble:
		b.EncodeVarint(6<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.DatumDouble))
	case *DatumMessage_DatumBool:
		t := uint64(0)
		if x.DatumBool {
			t = 1
		}
		b.EncodeVarint(7<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *DatumMessage_DatumString:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.DatumString)
	case *DatumMessage_DatumBytes:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.DatumBytes)
	case *DatumMessage_DatumPoint:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DatumPoint); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DatumMessage.Datum has unexpected type %T", x)
	}
	return nil
}

func _DatumMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DatumMessage)
	switch tag {
	case 3: // datum.datum_int32
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Datum = &DatumMessage_DatumInt32{int32(x)}
		return true, err
	case 4: // datum.datum_int64
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Datum = &DatumMessage_DatumInt64{int64(x)}
		return true, err
	case 5: // datum.datum_float
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Datum = &DatumMessage_DatumFloat{math.Float32frombits(uint32(x))}
		return true, err
	case 6: // datum.datum_double
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Datum = &DatumMessage_DatumDouble{math.Float64frombits(x)}
		return true, err
	case 7: // datum.datum_bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Datum = &DatumMessage_DatumBool{x != 0}
		return true, err
	case 8: // datum.datum_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Datum = &DatumMessage_DatumString{x}
		return true, err
	case 9: // datum.datum_bytes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Datum = &DatumMessage_DatumBytes{x}
		return true, err
	case 10: // datum.datum_point
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Point)
		err := b.DecodeMessage(msg)
		m.Datum = &DatumMessage_DatumPoint{msg}
		return true, err
	default:
		return false, nil
	}
}

type RowMessage struct {
	TransactionId uint32          `protobuf:"varint,1,opt,name=transaction_id" json:"transaction_id,omitempty"`
	CommitTime    uint64          `protobuf:"varint,2,opt,name=commit_time" json:"commit_time,omitempty"`
	Table         string          `protobuf:"bytes,3,opt,name=table" json:"table,omitempty"`
	Op            Op              `protobuf:"varint,4,opt,name=op,enum=decoderbufs.Op" json:"op,omitempty"`
	NewTuple      []*DatumMessage `protobuf:"bytes,5,rep,name=new_tuple" json:"new_tuple,omitempty"`
	OldTuple      []*DatumMessage `protobuf:"bytes,6,rep,name=old_tuple" json:"old_tuple,omitempty"`
}

func (m *RowMessage) Reset()         { *m = RowMessage{} }
func (m *RowMessage) String() string { return proto.CompactTextString(m) }
func (*RowMessage) ProtoMessage()    {}

func (m *RowMessage) GetNewTuple() []*DatumMessage {
	if m != nil {
		return m.NewTuple
	}
	return nil
}

func (m *RowMessage) GetOldTuple() []*DatumMessage {
	if m != nil {
		return m.OldTuple
	}
	return nil
}

func init() {
	proto.RegisterEnum("decoderbufs.Op", Op_name, Op_value)
}
